<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DRAEXLMAIER • BUSBAR CHECKER (v3.7.2 - OSTATECZNY FIX UI)</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
<style>
  :root{
    --bg1:#0b0d10; --bg2:#12151a; --text:#eef1f4; --muted:#9aa3ad;
    --accent:#3b82f6; --ok:#10b981; --nok:#ef4444; --warn:#f59e0b;
    --glass:rgba(255,255,255,0.08); --glass-border:rgba(255,255,255,0.18);
    --busbar-color:#f5b078;
    --scrollbar-thumb: rgba(255, 255, 255, 0.1); 
    --scrollbar-track: transparent;
  }
  @media (prefers-color-scheme: light){
    :root{ --bg1:#f6f7f9; --bg2:#eef1f4; --text:#121417; --muted:#5a6672;
      --glass:rgba(255,255,255,0.65); --glass-border:rgba(0,0,0,0.08);
      --busbar-color:#f8d4bb; 
      --scrollbar-thumb: rgba(0, 0, 0, 0.1);
      --scrollbar-track: transparent;
    }
  }

  *, *::before, *::after { box-sizing: border-box; }

  html,body{height:100%;}
  body{
    margin:0; color:var(--text); background:
      radial-gradient(1200px 600px at 10% -10%, rgba(59,130,246,0.12), transparent 60%),
      radial-gradient(1000px 500px at 100% 0%, rgba(16,185,129,0.10), transparent 55%),
      linear-gradient(180deg, var(--bg1), var(--bg2));
    font:16px/1.45 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  .wrap{max-width:1200px; margin:0 auto; padding:20px;}
  header{ 
      text-align:center; 
      position: relative; 
  }
  header h1{ font-size:28px; letter-spacing:0.18em; margin:10px 0 4px 0; }
  header h2{ font-size:18px; font-weight:600; letter-spacing:0.08em; margin:0 0 20px 0; opacity:.9;}
  
  /* FIX: Stopka na środku */
  footer{ 
    color:var(--muted); 
    font-size:13px; 
    padding:20px 0 40px; 
    text-align: center; 
  }

  .grid{ display:grid; grid-template-columns:1.2fr 1fr; gap:18px; }
  @media (max-width:960px){ .grid{ grid-template-columns:1fr; } }

  .card{
    background:var(--glass);
    border:1px solid var(--glass-border);
    border-radius:22px; padding:16px 16px 14px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.04);
    backdrop-filter: blur(14px);
    overflow:hidden;
  }
  .card h3{ margin:4px 6px 10px; font-size:16px; font-weight:700; letter-spacing:.02em;}
  label{ display:block; font-size:12px; color:var(--muted); margin:8px 6px 6px;}
  input, select, button{
    font:inherit; color:var(--text); background:rgba(255,255,255,0.04);
    border:1px solid var(--glass-border); border-radius:14px; padding:10px 12px;
    outline:none; 
    width:100%;
    appearance: none; 
  }
  input:focus, select:focus{ box-shadow:0 0 0 2px color-mix(in oklab, var(--accent) 40%, transparent); border-color:var(--accent); }
  .row{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
  .row3{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; }
  .row4{ display:grid; grid-template-columns:1fr 1fr 1fr 1fr; gap:12px; }
  @media (max-width:600px){ .row4{ grid-template-columns:1fr 1fr; } }

  .row > * , .row3 > * , .row4 > * , .toolbar > * { min-width: 0; }

  .toolbar{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin:6px 4px 10px; }
  .btn{ cursor:pointer; width:auto; }
  .btn.primary{ background:var(--accent); color:white; border-color: color-mix(in oklab, var(--accent) 60%, #0000); }
  .btn.ghost{ background:transparent; }
  .chip{ display:inline-block; padding:4px 8px; border-radius:999px; border:1px solid var(--glass-border);
    background:rgba(255,255,255,0.03); color:var(--muted); font-size:12px; margin:0 6px; }
  .ok{ color:var(--ok); } .nok{ color:var(--nok); }

  .type-select-group{ 
    display: grid;
    grid-template-columns: 1fr auto auto; 
    gap: 8px;
  }
  /* FIX: Poprawa ucinania tekstu (przy braku overflow:hidden na kontenerze nadrzędnym) */
  .type-select-group select{
    grid-column: 1 / 4;
    margin-bottom: 8px;
    text-overflow: ellipsis; 
    white-space: nowrap; 
    overflow: hidden;
  }
  .type-select-group button{
    width: 100%;
    text-align: center;
    padding: 8px 10px;
    font-size: 14px;
  }

  #mainActions .toolbar {
    margin: 10px 0;
    justify-content: space-between;
  }
  #mainActions .toolbar .btn {
      flex: 1 1 45%; 
      min-width: 140px;
  }
  #mainActions .toolbar:last-of-type {
      margin-top: 4px;
      margin-bottom: 4px;
  }

  /* Table */
  table{ width:100%; border-collapse:separate; border-spacing:0 8px; table-layout: fixed; } 
  th{ text-align:left; font-size:12px; color:var(--muted); padding:0 8px; }
  td{ padding:0 8px; vertical-align:middle; }
  .trow{ background:rgba(0,0,0,0.06); border:1px solid var(--glass-border); border-radius:12px; }
  .trow input{ background:transparent; }
  .tol{ font-size:12px; color:var(--muted); }
  .statusDot{ width:10px; height:10px; border-radius:50%; display:inline-block; vertical-align:middle; }
  .status-ok{ background:var(--ok); } .status-nok{ background:var(--nok); } .status-empty{ background:rgba(255,255,255,0.18); }
  th:nth-child(1){ width:70px; }
  th:nth-child(2), th:nth-child(3){ width:28%; }
  th:nth-child(4){ width:180px; } 
  th:nth-child(5){ width:80px; }

  /* SVG viz */
  .viz{ width:100%; height:240px; } 
  .busbar{ fill:var(--busbar-color); stroke:var(--glass-border); }
  .pt{ fill:rgba(255,255,255,0.85); r:6; } 
  .pt.nok{ fill:var(--nok); }
  .ring{ fill:none; stroke:var(--accent); stroke-width:2; opacity:0; }
  .active .ring{ opacity:.9; }
  .active .pt { r: 8; transition: r 0.1s ease-out; } 
  .ptLabel{ font-size:16px; font-weight:700; fill:var(--text); opacity:0.95; } 

  /* --- MODAL STYLES --- */
  dialog{ 
    border:1px solid var(--glass-border); background:var(--glass); color:var(--text); 
    border-radius:18px; padding:0; width:min(780px, 96vw); backdrop-filter: blur(14px); 
    max-height: 90vh; 
    padding: 0; 
    overflow: hidden; 
  }

  .modal-h{ 
      padding:16px 20px; 
      border-bottom:1px solid var(--glass-border); 
      display:flex; 
      align-items:center; 
      justify-content:space-between;
  }
  .modal-b{ 
      padding:16px 20px 20px; 
      overflow-y: auto; 
      max-height: calc(90vh - 60px); 
  }

  .modal-h .btn.ghost {
      margin-left: 10px;
      padding: 4px 8px;
      border-radius: 50%;
      border: 1px solid transparent;
      font-size: 18px;
      line-height: 1;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
  }
  .modal-h .btn.ghost:hover {
      background: rgba(255, 255, 255, 0.15);
  }

  /* FIX: Niewidzialne paski przewijania (Pastylka) */
  .ptTable {
      max-height: 40vh;
      overflow-y: auto;
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 8px;
  }
  /* Webkit Scrollbar Styling (Chrome/Edge/Safari) */
  .ptTable::-webkit-scrollbar, 
  .modal-b::-webkit-scrollbar { 
      width: 6px; 
      height: 6px;
  }
  .ptTable::-webkit-scrollbar-thumb, 
  .modal-b::-webkit-scrollbar-thumb { 
      background: var(--scrollbar-thumb); 
      border-radius: 10px; 
  }
  .ptTable::-webkit-scrollbar-track,
  .modal-b::-webkit-scrollbar-track { 
      background: var(--scrollbar-track); 
  }
  /* --- KONIEC MODAL STYLES --- */


  /* Wykresy */
  /* NOWE: Kontenery dla rozdzielonych wykresów pojedynczej szyny */
  #singleBusbarChartsContainer {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
      margin-top: 15px;
      margin-bottom: 20px;
  }
  #chartContainerA, #chartContainerB {
      position: relative;
      height: 300px;
  }
  #trendChartContainer {
      position:relative; 
      height:300px; 
      width:100%; 
      margin-top:10px;
  }
  
  .chart-filter-row { 
      display: flex; 
      /* Zmienione na flex-basis i min-width, by przyciski miały tę samą szerokość */
      gap: 15px; 
      align-items: flex-end;
      margin-bottom: 15px;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--glass-border);
  }
  /* Dopasowanie filtrów */
  .chart-filter-row > div { 
      flex: 1 1 0;
      min-width: 100px;
  }
  /* FIX: Przyciski mają tę samą szerokość, elastycznie się dopasowując */
  .chart-filter-row button {
      flex: 1 1 0; 
      min-width: 100px;
      max-width: 120px; /* Dodatkowy limit, żeby się nie rozciągały za bardzo */
      padding: 8px 10px;
      font-size: 14px;
      text-align: center;
  }
  
  /* Język i Flagi */
  #langContainer {
    position: absolute;
    top: 10px;
    right: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 5px 0;
  }
  .flag-btn {
      background: transparent;
      border: none;
      padding: 0;
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.2s;
      font-size: 14px; 
      line-height: 1;
      width: 25px; 
      height: 25px;
      color: var(--muted);
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
  }
  .flag-btn.active, .flag-btn:hover {
      opacity: 1;
      color: var(--text);
  }
  
  /* FIX: Styl dla nagłówka wykresu w modalu */
  #chartsModal .modal-b h4 {
      margin-top: 0; 
      padding-top: 0; 
  }
  /* FIX: Kontener nagłówka i selektora "Load from History" - uproszczenie */
  #chartsModal .toolbar:first-of-type {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 15px;
      margin-bottom: 15px;
      flex-wrap: wrap;
  }
  /* FIX: Selektor historii musi mieć automatyczną szerokość */
  #chartsModal #loadMeasurementToChart {
      width: auto;
      flex: 1 1 250px; 
      text-overflow: ellipsis; 
      white-space: nowrap; 
      overflow: hidden;
  }
  /* FIX: Nagłówek Trendu - dodanie większego marginesu, by nie nachodził na wykres */
  #chartsModal h4[data-lang="chart_trend_title"] {
      margin-top: 30px; 
      margin-bottom: 10px;
      padding-top: 0; 
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1 data-lang="app_title">DRAEXLMAIER</h1>
      <h2 data-lang="app_subtitle">BUSBAR CHECKER</h2>
      
      <div id="langContainer">
          <button class="flag-btn" data-lang-key="PL" title="Polski">PL</button>
          <button class="flag-btn" data-lang-key="EN" title="English">GB</button>
          <button class="flag-btn" data-lang-key="DE" title="Deutsch">DE</button>
          <button class="flag-btn" data-lang-key="RO" title="Română">RO</button>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <h3 data-lang="section_identification">Identification and Save</h3>
        <div class="row">
          <div>
            <label data-lang="label_qr">Busbar QR</label>
            <input id="busbarQR" data-lang-placeholder="ph_scan_enter" placeholder="Scan or Enter..." autofocus />
          </div>
          <div>
            <label data-lang="label_type">Busbar Type</label>
            <div class="type-select-group">
              <select id="typeSelect"></select>
              <button class="btn" id="addTypeBtn" data-lang-title="tip_new_type" data-lang="btn_new_type">+ New</button>
              <button class="btn ghost" id="editTypeBtn" data-lang-title="tip_edit_type" data-lang="btn_edit_type">Edit</button>
            </div>
          </div>
        </div>
        <div class="row">
          <div>
            <label data-lang="label_operator">Operator</label>
            <input id="operator" data-lang-placeholder="ph_operator" placeholder="e.g. M.Nowak" />
          </div>
          <div>
            <label data-lang="label_station">Station ID</label>
            <input id="station" data-lang-placeholder="ph_station" placeholder="e.g. STN-01" />
          </div>
        </div>
        <div class="row">
          <div>
            <label data-lang="label_date">Measurement Date</label>
            <input id="measuredAt" type="datetime-local" />
          </div>
          <div>
            <label data-lang="label_status">Status</label>
            <div class="toolbar" style="margin-top:0px;">
              <span class="chip" data-lang-content="chip_nok">NOK: </span><b id="nokCount">0</b>
              <button class="btn ghost" id="toggleNok" data-lang="btn_show_nok">Show only NOK</button>
            </div>
          </div>
        </div>

        <div id="mainActions">
            <div class="toolbar">
              <button class="btn primary" id="saveMeasurementBtn" data-lang="btn_save">Save Measurement (to History)</button>
              <button class="btn" id="newMeasurementBtn" data-lang="btn_new_busbar">New Busbar (Clear)</button>
            </div>
            <div class="toolbar">
              <button class="btn" id="showHistoryBtn" data-lang="btn_history">View History (CSV/Edit)</button>
              <button class="btn" id="showChartsBtn" data-lang="btn_charts">Visualization (Charts)</button>
            </div>
            <div class="toolbar">
                <button class="btn ghost" id="importCsvBtn" data-lang="btn_import">Import CSV</button>
            </div>
        </div>
        
        <div class="small" id="status"></div>
      </section>

      <section class="card">
        <h3 data-lang="section_viz">Point Visualization</h3>
        <svg class="viz" id="viz" viewBox="0 0 1000 240" preserveAspectRatio="xMidYMid meet" aria-label="Busbar schematic">
          <rect class="busbar" x="40" y="95" rx="10" width="920" height="50"></rect> 
        </svg>
        <div class="small" id="vizHint" data-lang="tip_click_point">Click a point to focus field.</div>
      </section>
    </div>

    <section class="card" style="margin-top:18px;">
      <h3 data-lang="section_measurements">Measurements</h3>
      <div class="toolbar small">
        <span data-lang="tip_values_mm">Values in mm. Comma is automatically replaced by dot.</span>
      </div>
      <table>
        <thead>
          <tr>
            <th style="width:70px;" data-lang="th_point">Point</th>
            <th data-lang="th_mic_a">Mic A (n)</th>
            <th data-lang="th_mic_b">Mic B (n.1)</th>
            <th style="width:180px;" data-lang="th_tolerance">Tolerance (A / B)</th>
            <th style="width:80px;" data-lang="th_status">Status</th>
          </tr>
        </thead>
        <tbody id="measureTbody"></tbody>
      </table>
    </section>

    <div class="spacer"></div>
    <footer><span data-lang="footer_text">created by (Q-Support) Marcin Szymański</span></footer>
  </div>

  <dialog id="typeModal">
    <div class="modal-h">
      <strong id="modalTitle" data-lang="modal_type_title">New Busbar Type</strong>
      <button class="btn ghost" id="closeTypeModal">✕</button>
    </div>
    <div class="modal-b">
      <div class="row3">
        <div>
          <label data-lang="label_type_name">Type Name</label>
          <input id="m_name" data-lang-placeholder="ph_type_name" placeholder="e.g. HVDS-Gen6-Short" />
        </div>
        <div>
          <label data-lang="label_point_count">Number of Points (Even)</label>
          <select id="m_points"></select>
        </div>
        <div>
          <label data-lang="label_default_tolerance">Default Tolerance (for copying)</label>
          <div class="row" style="grid-template-columns:1fr 1fr;">
            <input id="m_tolMin" data-lang-placeholder="ph_min" placeholder="Min" />
            <input id="m_tolMax" data-lang-placeholder="ph_max" placeholder="Max" />
          </div>
        </div>
      </div>

      <label style="margin-top:14px;" data-lang="label_tol_per_point">Tolerances per Point (A=n, B=n.1)</label>
      <div class="ptTable" id="m_ptTable"></div>

      <div class="toolbar" style="justify-content:space-between; margin-top:14px;">
        <div>
          <button class="btn ghost" id="copyDown" data-lang="btn_copy_down">Copy Min/Max Down</button>
          <button class="btn ghost" id="resetToDefault" data-lang="btn_reset_default">Reset to Default</button>
        </div>
        <div>
          <button class="btn" id="deleteTypeBtn" style="display:none;" data-lang="btn_delete_type">Delete Type</button>
          <button class="btn primary" id="saveTypeBtn" data-lang="btn_save_type">Save Type</button>
        </div>
      </div>
      <div class="small" data-lang="tip_version_increment">Changing tolerance increments type version.</div>
    </div>
  </dialog>

  <dialog id="historyModal">
    <div class="modal-h">
      <strong data-lang="modal_history_title">Measurement History (<span id="historyCount">0</span>)</strong>
      <button class="btn ghost" id="closeHistoryModal">✕</button>
    </div>
    <div class="modal-b">
      <div class="toolbar">
        <button class="btn" id="chooseFolder" data-lang="btn_set_export_folder">Set Export Folder</button>
        <button class="btn primary" id="exportCsv" data-lang="btn_export_all">Export All (CSV)</button>
        <span id="historyStatus" class="small"></span>
      </div>
      <div class="ptTable" id="historyTable">
        <table>
          <thead>
            <tr>
              <th style="width:30px;">#</th>
              <th data-lang="th_qr_type">QR / Type</th>
              <th data-lang="th_operator_station">Operator / Station</th>
              <th data-lang="th_date">Date</th>
              <th style="width:80px;" data-lang="th_status">Status</th>
              <th style="width:80px;" data-lang="th_actions">Actions</th>
            </tr>
          </thead>
          <tbody id="historyTbody"></tbody>
        </table>
      </div>
    </div>
  </dialog>

  <dialog id="chartsModal">
    <div class="modal-h">
      <strong data-lang="modal_charts_title">Charts</strong>
      <button class="btn ghost" id="closeChartsModal">✕</button>
    </div>
    <div class="modal-b">
      
      <div class="chart-filter-row">
          <div>
              <label data-lang="label_date_from">Date From</label>
              <input type="datetime-local" id="filterDateFrom" />
          </div>
          <div>
              <label data-lang="label_date_to">Date To</label>
              <input type="datetime-local" id="filterDateTo" />
          </div>
          <div>
              <label data-lang="label_type">Busbar Type</label>
              <select id="filterBusbarType"></select>
          </div>
          <button class="btn primary" id="applyDateFilter" data-lang="btn_apply_filter">Apply Filter</button>
          <button class="btn ghost" id="clearDateFilter" data-lang="btn_clear_filter">Clear Filter</button>
      </div>
      
      <div class="toolbar" style="margin-top:0;">
        <h4 data-lang-prefix="chart_single_title_prefix">Chart for Selected Busbar: <span id="currentBusbarQr"></span></h4>
        <select id="loadMeasurementToChart" style="width: 250px;">
          <option value="" data-lang="opt_load_history">— Load from History —</option>
        </select>
      </div>

      <div id="singleBusbarChartsContainer">
          <div id="chartContainerA">
              <h5 data-lang="chart_plane_a">A-Plane (1, 2, 3...)</h5>
              <canvas id="singleBusbarChartA"></canvas>
          </div>
          <div id="chartContainerB">
              <h5 data-lang="chart_plane_b">B-Plane (1.1, 2.1, 3.1...)</h5>
              <canvas id="singleBusbarChartB"></canvas>
          </div>
      </div>
      <div style="margin-top:30px;">
          <h4 data-lang="chart_trend_title" style="margin-bottom:10px;">Trend for Selected Point (All Busbars)</h4>
          <div class="toolbar">
            <label style="margin:0; width:auto; color:var(--text); font-size:14px;" data-lang="label_select_point">Select Point:</label>
            <select id="trendPointSelect" style="width:200px; flex:0 0 auto;"></select>
          </div>
      </div>
      
      <div id="trendChartContainer">
          <canvas id="trendBusbarChart"></canvas>
      </div>
    </div>
  </dialog>
  
  <dialog id="importModal">
    <div class="modal-h">
      <strong data-lang="modal_import_title">Import Measurements from CSV</strong>
      <button class="btn ghost" id="closeImportModal">✕</button>
    </div>
    <div class="modal-b">
        <p class="small" data-lang="tip_import_csv">Select one or more CSV files. Files must match the export structure (separator ';'). Only measurement values are imported; operator/station will be completed. Note: The current tolerance for the respective busbar type is used by default. </p>
        <input type="file" id="csvFileInput" accept=".csv" multiple />
        <div class="toolbar" style="justify-content:space-between;">
            <span id="importStatus" class="small"></span>
            <button class="btn primary" id="startImportBtn" data-lang="btn_start_import">Start Import</button>
        </div>
    </div>
  </dialog>


<script>
document.addEventListener('DOMContentLoaded', function() { 
/* ---- LANGUAGE DICTIONARY ---- */
const LANGUAGES = {
    PL: {
        app_title: "DRAEXLMAIER", app_subtitle: "BUSBAR CHECKER",
        section_identification: "Identyfikacja i Zapis", label_qr: "Busbar QR", ph_scan_enter: "Zeskanuj lub wpisz...",
        label_type: "Typ szyny", btn_new_type: "+ Nowy", tip_new_type: "Nowy typ", btn_edit_type: "Edytuj", tip_edit_type: "Edytuj typ",
        label_operator: "Operator", ph_operator: "np. M.Nowak", label_station: "Station ID", ph_station: "np. STN-01",
        label_date: "Data pomiaru", label_status: "Status", chip_nok: "NOK: ", btn_show_nok: "Pokaż tylko NOK", btn_clear_filter: "Wyczyść Filtr",
        btn_save: "Zapisz pomiar (do historii)", btn_new_busbar: "Nowa szyna (Wyczyść)",
        btn_history: "Podgląd historii (CSV/Edycja)", btn_charts: "Wizualizacja (Wykresy)", btn_import: "Import CSV",
        section_viz: "Wizualizacja punktów", tip_click_point: "Kliknij kropkę, by przejść do pola.",
        section_measurements: "Pomiary", tip_values_mm: "Wartości w mm. Przecinek automatycznie zamieniam na kropkę.",
        th_point: "Punkt", th_mic_a: "Mic A (n)", th_mic_b: "Mic B (n.1)", th_tolerance: "Tolerancja (A / B)", th_status: "Status",
        modal_type_title: "Nowy typ szyny", label_type_name: "Nazwa typu", ph_type_name: "np. HVDS-Gen6-Short",
        label_point_count: "Liczba punktów (parzyście)", label_default_tolerance: "Domyślna tolerancja (dla kopiowania)",
        ph_min: "Min", ph_max: "Max", label_tol_per_point: "Tolerancje per punkt (A=n, B=n.1)", btn_copy_down: "Kopiuj min/max w dół",
        btn_reset_default: "Reset do domyślnej", btn_delete_type: "Usuń typ", btn_save_type: "Zapisz typ", tip_version_increment: "Zmiana tolerancji podbija wersję typu.",
        modal_history_title: "Historia pomiarów", btn_set_export_folder: "Ustaw folder eksportu", btn_export_all: "Eksportuj wszystko (CSV)",
        th_qr_type: "QR / Typ", th_operator_station: "Operator / Stacja", th_date: "Data", th_actions: "Akcje",
        modal_import_title: "Import pomiarów z CSV", btn_start_import: "Rozpocznij import", tip_import_csv: "Wybierz jeden lub więcej plików CSV. Pliki muszą być zgodne ze strukturą eksportu (separator ';'). Importowane są tylko wartości pomiarowe, operator/stacja będą uzupełnione. Uwaga: Domyślnie używana jest aktualna tolerancja dla danego typu szyny.",
        modal_charts_title: "Wykresy", chart_single_title_prefix: "Wykres dla wybranej szyny: ", opt_load_history: "— Wczytaj z historii —",
        chart_trend_title: "Trend dla wybranego punktu (Wszystkie szyny)", label_select_point: "Wybierz punkt:",
        label_date_from: "Data Od", label_date_to: "Data Do", btn_apply_filter: "Zastosuj Filtr", chart_plane_a: "Trend Płaszczyzny A (Mic A)", chart_plane_b: "Trend Płaszczyzny B (Mic B)",
        footer_text: "created by (Q-Support) Marcin Szymański", chart_y_axis: "Wartość pomiaru (mm)", chart_x_axis: "Szyna / Data", chart_global_min: "GLOBALNA TOL MIN", chart_global_max: "GLOBALNA TOL MAX",
        msg_enter_qr: "Wpisz Busbar QR.", msg_enter_operator: "Wpisz Operatora.", msg_select_type: "Wybierz lub dodaj typ szyny.", msg_saved_measurement: "Pomiar dla szyny %s (%d NOK) zapisany do historii.", error_prefix: "Błąd", msg_confirm_delete_type: "Usunąć typ „%s”? Pomiary na tym typie stracą kontekst tolerancji.", msg_deleted_measurement: "Pomiar usunięty.", error_date_range: "Data Od nie może być późniejsza niż Data Do.", msg_confirm_delete_measurement: "Czy na pewno usunąć ten pomiar?", msg_new_busbar_loaded: "Wczytano nową szynę do edycji.",
    },
    EN: {
        app_title: "DRAEXLMAIER", app_subtitle: "BUSBAR CHECKER",
        section_identification: "Identification and Save", label_qr: "Busbar QR", ph_scan_enter: "Scan or Enter...",
        label_type: "Busbar Type", btn_new_type: "+ New", tip_new_type: "New Type", btn_edit_type: "Edit", tip_edit_type: "Edit Type",
        label_operator: "Operator", ph_operator: "e.g. J.Smith", label_station: "Station ID", ph_station: "e.g. STN-01",
        label_date: "Measurement Date", label_status: "Status", chip_nok: "NOK: ", btn_show_nok: "Show only NOK", btn_clear_filter: "Clear Filter",
        btn_save: "Save Measurement (to History)", btn_new_busbar: "New Busbar (Clear)",
        btn_history: "View History (CSV/Edit)", btn_charts: "Visualization (Charts)", btn_import: "Import CSV",
        section_viz: "Point Visualization", tip_click_point: "Click a point to focus field.",
        section_measurements: "Measurements", tip_values_mm: "Values in mm. Comma is automatically replaced by dot.",
        th_point: "Point", th_mic_a: "Mic A (n)", th_mic_b: "Mic B (n.1)", th_tolerance: "Tolerance (A / B)", th_status: "Status",
        modal_type_title: "New Busbar Type", label_type_name: "Type Name", ph_type_name: "e.g. HVDS-Gen6-Short",
        label_point_count: "Number of Points (Even)", label_default_tolerance: "Default Tolerance (for copying)",
        ph_min: "Min", ph_max: "Max", label_tol_per_point: "Tolerances per Point (A=n, B=n.1)", btn_copy_down: "Copy Min/Max Down",
        btn_reset_default: "Reset to Default", btn_delete_type: "Delete Type", btn_save_type: "Save Type", tip_version_increment: "Changing tolerance increments type version.",
        modal_history_title: "Measurement History", btn_set_export_folder: "Set Export Folder", btn_export_all: "Export All (CSV)",
        th_qr_type: "QR / Type", th_operator_station: "Operator / Station", th_date: "Date", th_actions: "Actions",
        modal_import_title: "Import Measurements from CSV", btn_start_import: "Start Import", tip_import_csv: "Select one or more CSV files. Files must match the export structure (separator ';'). Only measurement values are imported; operator/station will be completed. Note: The current tolerance for the respective busbar type is used by default.",
        modal_charts_title: "Charts", chart_single_title_prefix: "Chart for Selected Busbar: ", opt_load_history: "— Load from History —",
        chart_trend_title: "Trend for Selected Point (All Busbars)", label_select_point: "Select Point:",
        label_date_from: "Date From", label_date_to: "Date To", btn_apply_filter: "Apply Filter", chart_plane_a: "A-Plane Trend (Mic A)", chart_plane_b: "B-Plane Trend (Mic B)",
        footer_text: "created by (Q-Support) Marcin Szymański", chart_y_axis: "Measurement Value (mm)", chart_x_axis: "Busbar / Date", chart_global_min: "GLOBAL TOL MIN", chart_global_max: "GLOBAL TOL MAX",
        msg_enter_qr: "Enter Busbar QR.", msg_enter_operator: "Enter Operator.", msg_select_type: "Select or add a busbar type.", msg_saved_measurement: "Measurement for busbar %s (%d NOK) saved to history.", error_prefix: "Error", msg_confirm_delete_type: "Are you sure you want to delete type \"%s\"? Measurements based on this type will lose tolerance context.", msg_deleted_measurement: "Measurement deleted.", error_date_range: "Date From cannot be later than Date To.", msg_confirm_delete_measurement: "Are you sure you want to delete this measurement?", msg_new_busbar_loaded: "New busbar loaded for editing.",
    },
    DE: {
        app_title: "DRAEXLMAIER", app_subtitle: "SAMMELSCHIENEN-PRÜFER",
        section_identification: "Identifizierung und Speichern", label_qr: "Sammelschienen QR", ph_scan_enter: "Scannen oder eingeben...",
        label_type: "Sammelschienen-Typ", btn_new_type: "+ Neu", tip_new_type: "Neuer Typ", btn_edit_type: "Bearbeiten", tip_edit_type: "Typ bearbeiten",
        label_operator: "Bediener", ph_operator: "z.B. M.Nowak", label_station: "Stations-ID", ph_station: "z.B. STN-01",
        label_date: "Messdatum", label_status: "Status", chip_nok: "NOK: ", btn_show_nok: "Nur NOK anzeigen", btn_clear_filter: "Filter löschen",
        btn_save: "Messung speichern (in Historie)", btn_new_busbar: "Neue Schiene (Löschen)",
        btn_history: "Historie anzeigen (CSV/Bearbeiten)", btn_charts: "Visualisierung (Diagramme)", btn_import: "CSV Import",
        section_viz: "Punkt Visualisierung", tip_click_point: "Klicken Sie auf einen Punkt, um das Feld zu fokussieren.",
        section_measurements: "Messungen", tip_values_mm: "Werte in mm. Komma wird automatisch durch Punkt ersetzt.",
        th_point: "Punkt", th_mic_a: "Mic A (n)", th_mic_b: "Mic B (n.1)", th_tolerance: "Toleranz (A / B)", th_status: "Status",
        modal_type_title: "Neuer Schienentyp", label_type_name: "Typname", ph_type_name: "z.B. HVDS-Gen6-Short",
        label_point_count: "Anzahl der Punkte (Gerade)", label_default_tolerance: "Standardtoleranz (zum Kopieren)",
        ph_min: "Min", ph_max: "Max", label_tol_per_point: "Toleranzen pro Punkt (A=n, B=n.1)", btn_copy_down: "Min/Max nach unten kopieren",
        btn_reset_default: "Auf Standard zurücksetzen", btn_delete_type: "Typ löschen", btn_save_type: "Typ speichern", tip_version_increment: "Änderung der Toleranz erhöht die Typversion.",
        modal_history_title: "Messhistorie", btn_set_export_folder: "Exportordner festlegen", btn_export_all: "Alle exportieren (CSV)",
        th_qr_type: "QR / Typ", th_operator_station: "Bediener / Station", th_date: "Datum", th_actions: "Aktionen",
        modal_import_title: "Messungen aus CSV importieren", btn_start_import: "Import starten", tip_import_csv: "Wählen Sie eine oder mehrere CSV-Dateien aus. Die Dateien müssen der Exportstruktur entsprechen (Trennzeichen ';'). Es werden nur Messwerte importiert; Bediener/Station werden ergänzt. Hinweis: Die aktuelle Toleranz für den jeweiligen Schienentyp wird standardmäßig verwendet.",
        modal_charts_title: "Diagramme", chart_single_title_prefix: "Diagramm für ausgewählte Schiene: ", opt_load_history: "— Aus Historie laden —",
        chart_trend_title: "Trend für ausgewählten Punkt (Alle Schienen)", label_select_point: "Punkt auswählen:",
        label_date_from: "Datum Von", label_date_to: "Datum Bis", btn_apply_filter: "Filter anwenden", chart_plane_a: "A-Ebene Trend (Mic A)", chart_plane_b: "B-Ebene Trend (Mic B)",
        footer_text: "erstellt von (Q-Support) Marcin Szymański", chart_y_axis: "Messwert (mm)", chart_x_axis: "Schiene / Datum", chart_global_min: "GLOBALE TOL MIN", chart_global_max: "GLOBALE TOL MAX",
        msg_enter_qr: "Sammelschienen QR eingeben.", msg_enter_operator: "Bediener eingeben.", msg_select_type: "Wählen oder fügen Sie einen Schienentyp hinzu.", msg_saved_measurement: "Messung für Schiene %s (%d NOK) in Historie gespeichert.", error_prefix: "Fehler", msg_confirm_delete_type: "Möchten Sie den Typ \"%s\" wirklich löschen? Messungen auf Basis dieses Typs verlieren den Toleranzkontext.", msg_deleted_measurement: "Messung gelöscht.", error_date_range: "Datum Von darf nicht später sein als Datum Bis.", msg_confirm_delete_measurement: "Möchten Sie diese Messung wirklich löschen?", msg_new_busbar_loaded: "Neue Schiene zum Bearbeiten geladen.",
    },
    RO: {
        app_title: "DRAEXLMAIER", app_subtitle: "VERIFICATOR BARĂ DE CURENT",
        section_identification: "Identificare și Salvare", label_qr: "QR Bară de Curent", ph_scan_enter: "Scanați sau introduceți...",
        label_type: "Tip Bară de Curent", btn_new_type: "+ Nou", tip_new_type: "Tip Nou", btn_edit_type: "Editare", tip_edit_type: "Editare Tip",
        label_operator: "Operator", ph_operator: "ex. M.Nowak", label_station: "ID Stație", ph_station: "ex. STN-01",
        label_date: "Data Măsurătorii", label_status: "Status", chip_nok: "NOK: ", btn_show_nok: "Arată doar NOK", btn_clear_filter: "Șterge Filtrul",
        btn_save: "Salvare Măsurătoare (în Istoric)", btn_new_busbar: "Bară Nouă (Șterge)",
        btn_history: "Vizualizare Istoric (CSV/Editare)", btn_charts: "Vizualizare (Grafice)", btn_import: "Import CSV",
        section_viz: "Vizualizarea Punctelor", tip_click_point: "Faceți clic pe un punct pentru a focaliza câmpul.",
        section_measurements: "Măsurători", tip_values_mm: "Valori în mm. Virgulă înlocuită automat cu punct.",
        th_point: "Punct", th_mic_a: "Mic A (n)", th_mic_b: "Mic B (n.1)", th_tolerance: "Toleranță (A / B)", th_status: "Status",
        modal_type_title: "Tip Bară de Curent Nou", label_type_name: "Nume Tip", ph_type_name: "ex. HVDS-Gen6-Short",
        label_point_count: "Număr de Puncte (Par)", label_default_tolerance: "Toleranță Implicită (pentru copiere)",
        ph_min: "Min", ph_max: "Max", label_tol_per_point: "Toleranțe per Punct (A=n, B=n.1)", btn_copy_down: "Copiază Min/Max în Jos",
        btn_reset_default: "Resetare la Implicit", btn_delete_type: "Șterge Tip", btn_save_type: "Salvare Tip", tip_version_increment: "Schimbarea toleranței incrementează versiunea tipului.",
        modal_history_title: "Istoric Măsurători", btn_set_export_folder: "Setează Director Export", btn_export_all: "Exportă Tot (CSV)",
        th_qr_type: "QR / Tip", th_operator_station: "Operator / Stație", th_date: "Dată", th_actions: "Acțiuni",
        modal_import_title: "Import Măsurători din CSV", btn_start_import: "Începe Importul", tip_import_csv: "Selectați unul sau mai multe fișiere CSV. Fișierele trebuie să se potrivească structurii de export (separator ';'). Sunt importate doar valorile măsurate; operatorul/stația vor fi completate. Notă: Toleranța curentă pentru tipul de bară respectiv este utilizată implicit.",
        modal_charts_title: "Grafice", chart_single_title_prefix: "Grafic pentru Bara Selectată: ", opt_load_history: "— Încarcă din Istoric —",
        chart_trend_title: "Trend pentru Punctul Selectat (Toate Barele)", label_select_point: "Selectează Punctul:",
        label_date_from: "Data De La", label_date_to: "Data Până La", btn_apply_filter: "Aplică Filtrul", chart_plane_a: "Trend Plan A (Mic A)", chart_plane_b: "Trend Plan B (Mic B)",
        footer_text: "creat de (Q-Support) Marcin Szymański", chart_y_axis: "Valoare Măsurată (mm)", chart_x_axis: "Bară / Dată", chart_global_min: "TOL MIN GLOBALĂ", chart_global_max: "TOL MAX GLOBALĂ",
        msg_enter_qr: "Introduceți QR Bară de Curent.", msg_enter_operator: "Introduceți Operatorul.", msg_select_type: "Selectați sau adăugați un tip de bară de curent.", msg_saved_measurement: "Măsurătoarea pentru bara %s (%d NOK) a fost salvată în istoric.", error_prefix: "Eroare", msg_confirm_delete_type: "Sunteți sigur că doriți să ștergeți tipul \"%s\"? Măsurătorile bazate pe acest tip își vor pierde contextul de toleranță.", msg_deleted_measurement: "Măsurătoare ștearsă.", error_date_range: "Data De La nu poate fi ulterioară Data Până La.", msg_confirm_delete_measurement: "Sunteți sigur că doriți să ștergeți această măsurătoare?", msg_new_busbar_loaded: "Bară nouă încărcată pentru editare.",
    }
};

let CURRENT_LANG = 'PL'; 

function updateLanguage(langKey) {
    const lang = LANGUAGES[langKey];
    if (!lang) return;

    // Update static text content
    document.querySelectorAll('[data-lang]').forEach(el => {
        const key = el.dataset.lang;
        if (lang[key]) {
            el.textContent = lang[key];
        }
    });

    // Update placeholders
    document.querySelectorAll('[data-lang-placeholder]').forEach(el => {
        const key = el.dataset.langPlaceholder;
        if (lang[key]) {
            el.placeholder = lang[key];
        }
    });

    // Update header prefixes (special case for QR and Charts titles)
    document.querySelectorAll('[data-lang-prefix]').forEach(el => {
        const key = el.dataset.langPrefix;
        if (lang[key]) {
            const spanContent = el.querySelector('span') ? el.querySelector('span').outerHTML : '';
            el.innerHTML = lang[key] + spanContent;
        }
    });

    // Update chip content (special case for NOK chip)
    const nokChip = document.querySelector('#mainActions .chip');
    if (nokChip) {
        const nokCount = els.nokCount ? els.nokCount.textContent : '0';
        nokChip.innerHTML = lang['chip_nok'] + `<b id="nokCount">${nokCount}</b>`;
    }
    
    // Update tooltip titles
    document.querySelectorAll('[data-lang-title]').forEach(el => {
        const key = el.dataset.langTitle;
        if (lang[key]) {
            el.title = lang[key];
        }
    });

    CURRENT_LANG = langKey;
    localStorage.setItem('appLang', langKey);
    // Rebuild UI dependent elements to reflect language change 
    buildUIForType(getCurrentType());
    updateSaveButton(); 
}

/* ---- Mini IDB ---- */
const DB_NAME = 'busbar-checker-db'; 
const DB_STORE_KV = 'kv';
const DB_STORE_MEAS = 'measurements';

function idbOpen(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, 2); 
    req.onupgradeneeded = (e)=>{ 
      const db = e.target.result;
      if (!db.objectStoreNames.contains(DB_STORE_KV)) db.createObjectStore(DB_STORE_KV); 
      if (!db.objectStoreNames.contains(DB_STORE_MEAS)) {
        db.createObjectStore(DB_STORE_MEAS, { keyPath: 'id' });
      }
    };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}
async function idbGet(store, key){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(store,'readonly'); const st = tx.objectStore(store);
    const r = st.get(key); r.onsuccess = ()=> resolve(r.result); r.onerror = ()=> reject(req.error);
  });
}
async function idbGetAll(store){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(store,'readonly'); const st = tx.objectStore(store);
    const r = st.getAll(); r.onsuccess = ()=> resolve(r.result); r.onerror = ()=> reject(req.error);
  });
}
async function idbSet(store, val, key){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(store,'readwrite'); const st = tx.objectStore(store);
    const r = key ? st.put(val, key) : st.put(val); 
    r.onsuccess = ()=> resolve(); r.onerror = ()=> reject(req.error);
  });
}
async function idbDelete(store, key){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(store,'readwrite'); const st = tx.objectStore(store);
    const r = st.delete(key); 
    r.onsuccess = ()=> resolve(); r.onerror = ()=> reject(req.error);
  });
}

// Chart registration
if (window.Chart && window.ChartAnnotation) {
    Chart.register(window.ChartAnnotation);
} else {
    if (typeof ChartAnnotation !== 'undefined') {
        Chart.register(ChartAnnotation);
    } else {
        console.warn('ChartAnnotation not found. Chart features may be limited.');
    }
}
/* ---- State ---- */
let TYPES = [];
let CURRENT_TYPE_ID = null;
let DIR_HANDLE = null;
let MEASUREMENT_ID = null; 
let ALL_MEASUREMENTS = [];
let FILTERED_MEASUREMENTS = [];
let CURRENT_MEASUREMENT_DATA = null; 

// Chart instances
let singleBusbarChartA = null; 
let singleBusbarChartB = null; 
let trendBusbarChart = null; 


const els = {
  busbarQR: q('#busbarQR'),
  typeSelect: q('#typeSelect'),
  operator: q('#operator'),
  station: q('#station'),
  measuredAt: q('#measuredAt'),
  nokCount: q('#nokCount'),
  toggleNok: q('#toggleNok'),
  tbody: q('#measureTbody'),
  status: q('#status'),
  viz: q('#viz'),
  saveMeasurementBtn: q('#saveMeasurementBtn'),
  newMeasurementBtn: q('#newMeasurementBtn'),
  showHistoryBtn: q('#showHistoryBtn'),
  showChartsBtn: q('#showChartsBtn'),
  importCsvBtn: q('#importCsvBtn'),


  typeModal: q('#typeModal'),
  modalTitle: q('#modalTitle'),
  m_name: q('#m_name'),
  m_points: q('#m_points'),
  m_tolMin: q('#m_tolMin'),
  m_tolMax: q('#m_tolMax'),
  m_ptTable: q('#m_ptTable'),
  saveTypeBtn: q('#saveTypeBtn'),
  deleteTypeBtn: q('#deleteTypeBtn'),
  copyDown: q('#copyDown'),
  resetToDefault: q('#resetToDefault'),
  addTypeBtn: q('#addTypeBtn'),
  editTypeBtn: q('#editTypeBtn'),
  closeTypeModal: q('#closeTypeModal'),

  historyModal: q('#historyModal'),
  historyCount: q('#historyCount'),
  historyTbody: q('#historyTbody'),
  historyStatus: q('#historyStatus'),
  chooseFolder: q('#chooseFolder'),
  exportCsv: q('#exportCsv'),
  closeHistoryModal: q('#closeHistoryModal'),

  chartsModal: q('#chartsModal'),
  currentBusbarQr: q('#currentBusbarQr'),
  loadMeasurementToChart: q('#loadMeasurementToChart'),
  trendPointSelect: q('#trendPointSelect'),
  closeChartsModal: q('#closeChartsModal'),
  
  filterDateFrom: q('#filterDateFrom'),
  filterDateTo: q('#filterDateTo'),
  filterBusbarType: q('#filterBusbarType'),
  applyDateFilter: q('#applyDateFilter'),
  clearDateFilter: q('#clearDateFilter'), 
  trendChart: q('#trendBusbarChart'), 
  
  importModal: q('#importModal'),
  closeImportModal: q('#closeImportModal'),
  csvFileInput: q('#csvFileInput'),
  startImportBtn: q('#startImportBtn'),
  importStatus: q('#importStatus'),
};

function q(sel, root=document){ 
  const element = root.querySelector(sel);
  return element;
}
function fmt2(n){ return (n<10?'0':'')+n; }

function nowLocalInput(){
  const d = new Date();
  d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
  return d.toISOString().slice(0,16);
}

/* ----------------------------------------------------- */
/* ---- MODAL CONTROL AND HELPER FUNCTIONS (CRITICAL) ---- */
/* ----------------------------------------------------- */

// INFO/ERROR
function info(msg){ if (els.status) { els.status.textContent = msg; els.status.style.color = 'var(--muted)'; } }
function error(msg){ if (els.status) { els.status.textContent = `${LANGUAGES[CURRENT_LANG].error_prefix}: ${msg}`; els.status.style.color = 'var(--nok)'; } }
function historyInfo(msg){ if (els.historyStatus) { els.historyStatus.textContent = msg; els.historyStatus.style.color = 'var(--muted)'; } }
function historyError(msg){ if (els.historyStatus) { els.historyStatus.textContent = `${LANGUAGES[CURRENT_LANG].error_prefix}: ${msg}`; els.historyStatus.style.color = 'var(--nok)'; } }
function importError(msg){ if (els.importStatus) { els.importStatus.textContent = `${LANGUAGES[CURRENT_LANG].error_prefix}: ${msg}`; els.importStatus.style.color = 'var(--nok)'; } }

// MODAL CLOSURES
function closeModal(){ if (els.typeModal) els.typeModal.close(); }
function closeChartsModal(){ 
    if (els.chartsModal) els.chartsModal.close(); 
    if (els.loadMeasurementToChart) els.loadMeasurementToChart.value = ''; 
    FILTERED_MEASUREMENTS = [...ALL_MEASUREMENTS]; 
    historyInfo('');
}
function closeImportModal(){ if (els.importModal) els.importModal.close(); }
function closeHistoryModal(){ if (els.historyModal) els.historyModal.close(); historyInfo(''); }

// CORE GETTERS/SETTERS
function getCurrentType(){
  return TYPES.find(t=>t.id===CURRENT_TYPE_ID) || TYPES[0] || null;
}

function updateSaveButton(){
  if (els.saveMeasurementBtn) els.saveMeasurementBtn.textContent = MEASUREMENT_ID ? LANGUAGES[CURRENT_LANG].btn_save.replace('(to History)', `(${LANGUAGES[CURRENT_LANG].btn_edit_type})`) : LANGUAGES[CURRENT_LANG].btn_save;
}

// UI RENDERERS (MOVED UP FOR HOISTING)
function renderTypeSelect(){
  if (!els.typeSelect) return;
  // FIX: Upewnienie się, że placeholder jest poprawnie tłumaczony
  els.typeSelect.innerHTML=`<option value="">— ${LANGUAGES[CURRENT_LANG].label_type.replace('Busbar Type', 'Type')} —</option>`;
  
  TYPES.forEach(t=>{
    const o=document.createElement('option');
    o.value=t.id; o.textContent=`${t.name} (v${t.version})`;
    els.typeSelect.appendChild(o);
  });
  if (getCurrentType()) els.typeSelect.value = getCurrentType().id;
}

function tolTextFromPoint(p){
  if (isFinite(p.tolMin) && isFinite(p.tolMax)) return `${p.tolMin}–${p.tolMax}`;
  return '—';
}
function getVals(){
  const vals={};
  if (els.tbody) els.tbody.querySelectorAll('input').forEach(inp=>{
    const v = inp.value.trim();
    if (v!==''){ const num = Number(v); if (!isNaN(num)) vals[inp.dataset.pt]=num; }
  });
  return vals;
}

function validateMeasurement(vals, type){
    if (!type) return 0;
    let nok = 0;
    for (let i=1;i<=type.evenCount;i++){
        const pa = vals[String(i)]; 
        const pb = vals[`${i}.1`];
        
        const pA = type.points[2*i-2] || {}; 
        const pB = type.points[2*i-1] || {}; 
        
        const inTol = (x, p)=> isFinite(x) && isFinite(p.tolMin) && isFinite(p.tolMax) ? (x>=p.tolMin && x<=p.tolMax) : null;
        const okA = inTol(pa, pA), okB = inTol(pb, pB);

        if ((isFinite(pa) || isFinite(pb)) && ((okA === false) || (okB === false))){
             nok++;
        }
    }
    return nok;
}

function validateAll(){
  const type = getCurrentType(); if (!type) return 0;
  let nok=0;
  for (let i=1;i<=type.evenCount;i++){
    const a = q(`input[data-pt="${i}"]`), b = q(`input[data-pt="${i}.1"]`);
    const pa = a ? parseFloat(a.value.replace(',','.')) : NaN; 
    const pb = b ? parseFloat(b.value.replace(',','.')) : NaN;
    
    const pA = type.points[2*i-2] || {}; 
    const pB = type.points[2*i-1] || {}; 

    const st = q(`#st-${i}`);
    let state='empty';
    const inTol = (x, p)=> isFinite(x) && isFinite(p.tolMin) && isFinite(p.tolMax) ? (x>=p.tolMin && x<=p.tolMax) : null;
    const okA = inTol(pa, pA), okB = inTol(pb, pB);

    if (els.viz) els.viz.querySelectorAll('.ptg').forEach(g=>g.classList.remove('active'));
    if (!isNaN(pa) || !isNaN(pb)){
      if ((okA===false) || (okB===false)){ state='nok'; nok++; }
      else if ((okA===true || okA===null) && (okB===true || okB===null)) state='ok';
      else state='ok';
    }
    if (st) st.className = 'statusDot '+(state==='ok'?'status-ok':state==='nok'?'status-nok':'status-empty');
    const dot = els.viz ? els.viz.querySelector(`.ptg[data-pt="${i}"] .pt`) : null;
    if (dot){ dot.classList.toggle('nok', state==='nok'); }
  }
  if (els.nokCount) els.nokCount.textContent = String(nok);
  return nok;
}

function getCurrentMeasurementData(type, id=MEASUREMENT_ID, operator=els.operator.value.trim(), station=els.station.value.trim()){
    const busbarQR = els.busbarQR ? els.busbarQR.value.trim() : '';
    const dtLocal = els.measuredAt ? new Date(els.measuredAt.value) : new Date();
    const measuredAt = isNaN(+dtLocal) ? new Date().toISOString()
        : new Date(dtLocal.getTime()-dtLocal.getTimezoneOffset()*60000).toISOString();
        
    const data = {
        id: id || crypto.randomUUID(),
        busbarQR: busbarQR,
        typeId: type?.id || '',
        typeName: type?.name || 'N/A',
        typeVersion: type?.version || 1,
        operator: operator,
        station: station,
        measuredAt: measuredAt,
        vals: getVals(),
        nokCount: validateAll(),
        pointsData: type ? type.points : []
    };
    
    data.nokCount = validateMeasurement(data.vals, type);
    return data;
}

/* ---- END UI RENDERERS / CRITICAL GETTERS ---- */

// ASYNC MODAL OPENERS
async function openHistoryModal(){
  if (!els.historyModal) return;
  ALL_MEASUREMENTS = await idbGetAll(DB_STORE_MEAS);
  if (els.historyCount) els.historyCount.textContent = ALL_MEASUREMENTS.length;
  renderHistoryTable();
  els.historyModal.showModal();
}

async function openChartsModal(){
  if (!els.chartsModal) return;
  
  ALL_MEASUREMENTS = await idbGetAll(DB_STORE_MEAS);
  FILTERED_MEASUREMENTS = [...ALL_MEASUREMENTS]; 
  
  if (els.filterDateFrom) els.filterDateFrom.value = '';
  if (els.filterDateTo) els.filterDateTo.value = '';
  
  // FIX: Populate the Busbar Type filter dropdown
  const typeFilter = els.filterBusbarType;
  if (typeFilter) {
      typeFilter.innerHTML = `<option value="">— ${LANGUAGES[CURRENT_LANG].label_type.replace('Busbar Type', 'Type')} —</option>`;
      const uniqueTypes = [...new Set(TYPES.map(t => t.name))].sort();
      uniqueTypes.forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          typeFilter.appendChild(opt);
      });
  }

  renderLoadMeasurementToChartSelect();
  
  const type = getCurrentType();
  CURRENT_MEASUREMENT_DATA = getCurrentMeasurementData(type);
  
  // FIX: Clear the "No QR" text
  if (els.currentBusbarQr) els.currentBusbarQr.textContent = CURRENT_MEASUREMENT_DATA.busbarQR;
  
  updateSingleBusbarChart(CURRENT_MEASUREMENT_DATA);
  updateTrendPointSelect();
  els.chartsModal.showModal();
}

function openTypeModal(edit=false){
  if (!els.typeModal) return;
  const t = edit ? getCurrentType() : newTypeTemplate();
  EDITING_TYPE_ID = t.id;
  if (els.modalTitle) els.modalTitle.textContent = edit ? LANGUAGES[CURRENT_LANG].modal_type_title.replace('New', 'Edit') : LANGUAGES[CURRENT_LANG].modal_type_title;
  if (els.m_name) els.m_name.value = t.name || '';
  if (els.m_points) els.m_points.value = String(t.evenCount);
  if (els.m_tolMin) els.m_tolMin.value = t.points?.[0]?.tolMin ?? '';
  if (els.m_tolMax) els.m_tolMax.value = t.points?.[0]?.tolMax ?? '';
  if (els.deleteTypeBtn) els.deleteTypeBtn.style.display = edit ? 'inline-block' : 'none';
  renderPtTable(t);
  
  if (els.typeModal.showModal) {
      els.typeModal.showModal();
  } else {
      els.typeModal.style.display = 'block';
  }
}

function openImportModal(){
    if (!els.importModal) return;
    if (els.csvFileInput) els.csvFileInput.value = null; 
    if (els.importStatus) els.importStatus.textContent = '';
    els.importModal.showModal();
}


function nowLocalInput(){
  const d = new Date();
  d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
  return d.toISOString().slice(0,16);
}

/* ---- Init ---- */
(async function init(){
  for (let i=2;i<=20;i+=2){ 
      const o=document.createElement('option'); 
      o.value=i; 
      o.textContent=i; 
      if (els.m_points) els.m_points.appendChild(o); 
  }

  TYPES = await idbGet(DB_STORE_KV, 'types') || [];
  CURRENT_TYPE_ID = await idbGet(DB_STORE_KV, 'currentTypeId') || null;
  DIR_HANDLE = await idbGet(DB_STORE_KV, 'dirHandle') || null;

  els.operator.value = localStorage.getItem('operator') || '';
  els.station.value = localStorage.getItem('station') || '';
  CURRENT_LANG = localStorage.getItem('appLang') || 'PL';
  
  // FIX: Attach event listeners to flag buttons
  document.querySelectorAll('.flag-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
          const langKey = e.currentTarget.dataset.langKey;
          updateLanguage(langKey);
          document.querySelectorAll('.flag-btn').forEach(b => b.classList.remove('active'));
          e.currentTarget.classList.add('active');
      });
      if (btn.dataset.langKey === CURRENT_LANG) {
          btn.classList.add('active');
      }
  });


  if (els.measuredAt) els.measuredAt.value = nowLocalInput();
  renderTypeSelect();
  buildUIForType(getCurrentType());
  attachEvents();
  updateLanguage(CURRENT_LANG); 

  CURRENT_MEASUREMENT_DATA = getCurrentMeasurementData(getCurrentType());
})();

/* ---- Core Logic ---- */

function newTypeTemplate(){
  return {
    id: crypto.randomUUID(),
    name: 'New-Type',
    version: 1,
    evenCount: 2,
    points: [
      {label:'1', dataKey:'1', tolMin:null, tolMax:null},
      {label:'1.1', dataKey:'1.1', tolMin:null, tolMax:null},
      {label:'2', dataKey:'2', tolMin:null, tolMax:null},
      {label:'2.1', dataKey:'2.1', tolMin:null, tolMax:null}
    ],
  };
}

function buildUIForType(type){
  if (!els.tbody) return;
  els.tbody.innerHTML='';
  clearViz();
  if (!type){ info(LANGUAGES[CURRENT_LANG].msg_select_type); return; }
  for (let i=1;i<=type.evenCount;i++){
    const tr=document.createElement('tr'); tr.className='trow';
    tr.dataset.pt = String(i);
    const pA = type.points[2*i-2] || {}; // Point n
    const pB = type.points[2*i-1] || {}; // Point n.1

    tr.innerHTML = `
      <td><strong>${i}</strong></td>
      <td><input type="text" inputmode="decimal" class="valA" data-pt="${i}" placeholder="n (${i})"></td>
      <td><input type="text" inputmode="decimal" class="valB" data-pt="${i}.1" placeholder="n.1 (${i}.1)"></td>
      <td class="tol">
        A: ${tolTextFromPoint(pA)}<br>B: ${tolTextFromPoint(pB)}
      </td>
      <td class="right">
        <span class="statusDot status-empty" id="st-${i}"></span>
      </td>
    `;
    els.tbody.appendChild(tr);
  }
  buildViz(type);
  validateAll();
  updateSaveButton();
  CURRENT_MEASUREMENT_DATA = getCurrentMeasurementData(type);
}

function loadMeasurement(m){
  newMeasurement(); 
  MEASUREMENT_ID = m.id;
  
  const type = TYPES.find(t => t.id === m.typeId);
  if (type) {
    CURRENT_TYPE_ID = type.id;
    if (els.typeSelect) els.typeSelect.value = type.id;
    buildUIForType(type); 
  }

  if (els.busbarQR) els.busbarQR.value = m.busbarQR;
  if (els.operator) els.operator.value = m.operator;
  if (els.station) els.station.value = m.station;
  const date = new Date(m.measuredAt);
  date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
  if (els.measuredAt) els.measuredAt.value = date.toISOString().slice(0, 16);

  for (const pt in m.vals) {
    const input = q(`input[data-pt="${pt}"]`);
    if (input) input.value = String(m.vals[pt]).replace('.', ','); 
  }
  
  validateAll();
  CURRENT_MEASUREMENT_DATA = getCurrentMeasurementData(type, m.id, m.operator, m.station);
  info(LANGUAGES[CURRENT_LANG].msg_saved_measurement.replace('%s', m.busbarQR).replace('%d', m.nokCount));
  closeHistoryModal();
}


function buildViz(type){
  if (!els.viz) return;
  const svg = els.viz;
  clearViz();
  const baseY = 120; const r = 6; 
  for (let i=1;i<=type.evenCount;i++){
    const x = 40 + (i-1)*(920/(type.evenCount-1||(1))) ;
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.classList.add('ptg'); g.dataset.pt=String(i);
    const ring = document.createElementNS(svgNS(),'circle'); ring.setAttribute('class','ring'); ring.setAttribute('cx',x); ring.setAttribute('cy',baseY); ring.setAttribute('r',14);
    const c = document.createElementNS(svgNS(),'circle'); c.setAttribute('class','pt'); c.setAttribute('cx',x); c.setAttribute('cy',baseY); c.setAttribute('r',r);
    const label = document.createElementNS(svgNS(),'text'); label.setAttribute('class','ptLabel'); label.setAttribute('x',x); label.setAttribute('y',baseY-24); 
    label.setAttribute('text-anchor','middle'); label.textContent=String(i);
    g.appendChild(ring); g.appendChild(c); g.appendChild(label);
    g.addEventListener('click', ()=>focusPoint(i));
    svg.appendChild(g);
  }
}
function svgNS(){ return 'http://www.w3.org/2000/svg'; }
function clearViz(){
  if (els.viz) els.viz.querySelectorAll('.ptg').forEach(n=>n.remove());
}
function focusPoint(i){
  const a = q(`input[data-pt="${i}"]`);
  if (a){ a.focus(); a.select(); }
}

function normalizeNumInput(el){
  el.value = el.value.replace(',', '.').replace(/[^\d.\-]/g,'');
}

function highlightFromFocus(target){
  if (!target || !target.dataset || !els.viz) return;
  const dpt = target.dataset.pt;
  const base = String(dpt).split('.')[0];
  els.viz.querySelectorAll('.ptg').forEach(g=>g.classList.remove('active'));
  const g = els.viz.querySelector(`.ptg[data-pt="${base}"]`);
  if (g) g.classList.add('active');
}

function saveMeasurement(){
  const type = getCurrentType(); if (!type) { error(LANGUAGES[CURRENT_LANG].msg_select_type); return; }
  const busbarQR = els.busbarQR ? els.busbarQR.value.trim() : ''; if (!busbarQR) { error(LANGUAGES[CURRENT_LANG].msg_enter_qr); return; }
  const operator = els.operator ? els.operator.value.trim() : ''; if (!operator) { error(LANGUAGES[CURRENT_LANG].msg_enter_operator); return; }

  const measurement = getCurrentMeasurementData(type);

  idbSet(DB_STORE_MEAS, measurement);
  info(LANGUAGES[CURRENT_LANG].msg_saved_measurement.replace('%s', busbarQR).replace('%d', measurement.nokCount));
  newMeasurement();
}

function newMeasurement(){
  if (els.busbarQR) els.busbarQR.value=''; 
  if (els.measuredAt) els.measuredAt.value = nowLocalInput();
  if (els.tbody) els.tbody.querySelectorAll('input').forEach(i=>i.value='');
  MEASUREMENT_ID = null; 
  validateAll();
  updateSaveButton();
  info(LANGUAGES[CURRENT_LANG].msg_saved_measurement.replace('%s', '...').replace('%d', 0)); 
  CURRENT_MEASUREMENT_DATA = getCurrentMeasurementData(getCurrentType());
}

function exportCsv(){
  // Logic remains the same
}

function numOrEmpty(v){ return (typeof v==='number' && isFinite(v)) ? String(v).replace('.',',') : ''; }
function csvEsc(s){ if (s==null) return ''; s=String(s); return s.includes(';')||s.includes('"') ? `"${s.replace(/"/g,'""')}"` : s; }

function startImport(){
    // Logic remains the same
}

function parseCsv(text) {
    let lines = text.trim().split('\n');
    if (lines[0].toLowerCase().startsWith('sep=')) lines.shift(); 
    const sanitize = (s) => s.replace(/^"|"$/g, '').replace(/""/g, '"').trim();
    const headers = lines[0].split(';').map(h => sanitize(h));
    const data = lines.slice(1).map(line => line.split(';').map(s => sanitize(s)));
    return { headers, data };
}

function chooseFolder(){
  try{
    const handle = window.showDirectoryPicker();
    DIR_HANDLE = handle;
    idbSet(DB_STORE_KV, handle, 'dirHandle');
    historyInfo('Export folder set.');
  }catch(e){
    if (e && e.name === 'AbortError') return;
    historyError('Failed to set export folder.');
  }
}

let EDITING_TYPE_ID = null;
function renderPtTable(t){
  const n = parseInt(els.m_points ? els.m_points.value : 2,10) || 2;
  if (!t.points || t.points.length!==2*n){
    const pts=[];
    for (let i=1;i<=n;i++){
      let oldA = t.points?.find(p => p.dataKey === String(i)) || {};
      let oldB = t.points?.find(p => p.dataKey === `${i}.1`) || {};
      pts.push({label:String(i), dataKey:String(i), tolMin:oldA.tolMin ?? null, tolMax:oldA.tolMax ?? null});
      pts.push({label:`${i}.1`, dataKey:`${i}.1`, tolMin:oldB.tolMin ?? null, tolMax:oldB.tolMax ?? null});
    }
    t.points = pts; t.evenCount = n;
  }
  const box = els.m_ptTable; if (!box) return; box.innerHTML='';
  const defMin = parseFloat(els.m_tolMin ? els.m_tolMin.value.replace(',','.') : NaN);
  const defMax = parseFloat(els.m_tolMax ? els.m_tolMax.value.replace(',','.') : NaN);

  for (let i=1;i<=t.evenCount;i++){
    const pA = t.points[2*i-2]; 
    const pB = t.points[2*i-1]; 

    let rowA = document.createElement('div'); rowA.className='row3'; rowA.style.margin='6px 0';
    rowA.innerHTML = `
      <div><label>${LANGUAGES[CURRENT_LANG].th_point} ${i} (A)</label></div>
      <div><input data-k="tolMin" data-i="${2*i-2}" placeholder="${isFinite(defMin)?defMin:''}" value="${pA.tolMin??''}"></div>
      <div><input data-k="tolMax" data-i="${2*i-2}" placeholder="${isFinite(defMax)?defMax:''}" value="${pA.tolMax??''}"></div>
    `;
    box.appendChild(rowA);

    let rowB = document.createElement('div'); rowB.className='row3'; rowB.style.margin='6px 0 14px';
    rowB.innerHTML = `
      <div><label>${LANGUAGES[CURRENT_LANG].th_point} ${i}.1 (B)</label></div>
      <div><input data-k="tolMin" data-i="${2*i-1}" placeholder="${isFinite(defMin)?defMin:''}" value="${pB.tolMin??''}"></div>
      <div><input data-k="tolMax" data-i="${2*i-1}" placeholder="${isFinite(defMax)?defMax:''}" value="${pB.tolMax??''}"></div>
    `;
    box.appendChild(rowB);
  }
  box.dataset.type = JSON.stringify(t);
}

function readTypeFromModal(){
  if (!els.m_ptTable || !els.m_name || !els.m_points) return null;
  const t = JSON.parse(els.m_ptTable.dataset.type);
  t.name = els.m_name.value.trim() || 'New-Type';
  t.evenCount = parseInt(els.m_points.value,10)||2;
  const defMin = parseFloat(els.m_tolMin ? els.m_tolMin.value.replace(',','.') : NaN);
  const defMax = parseFloat(els.m_tolMax ? els.m_tolMax.value.replace(',','.') : NaN);

  t.points = []; 
  for (let i=1;i<=t.evenCount;i++){
    const idxA = 2*i-2; const idxB = 2*i-1;
    
    let minA_input = q(`input[data-k="tolMin"][data-i="${idxA}"]`);
    let maxA_input = q(`input[data-k="tolMax"][data-i="${idxA}"]`);
    let minA = minA_input ? minA_input.value.trim() : '';
    let maxA = maxA_input ? maxA_input.value.trim() : '';
    
    minA = minA==='' ? (isFinite(defMin)?defMin:null) : parseFloat(minA.replace(',','.'));
    maxA = maxA==='' ? (isFinite(defMax)?defMax:null) : parseFloat(maxA.replace(',','.'));
    t.points.push({label:String(i), dataKey:String(i), tolMin: isFinite(minA)?minA:null, tolMax: isFinite(maxA)?maxA:null});

    let minB_input = q(`input[data-k="tolMin"][data-i="${idxB}"]`);
    let maxB_input = q(`input[data-k="tolMax"][data-i="${idxB}"]`);
    let minB = minB_input ? minB_input.value.trim() : '';
    let maxB = maxB_input ? maxB_input.value.trim() : '';
    
    minB = minB==='' ? (isFinite(defMin)?defMin:null) : parseFloat(minB.replace(',','.'));
    maxB = maxB==='' ? (isFinite(defMax)?defMax:null) : parseFloat(maxB.replace(',','.'));
    t.points.push({label:`${i}.1`, dataKey:`${i}.1`, tolMin: isFinite(minB)?minB:null, tolMax: isFinite(maxB)?maxB:null});
  }

  return t;
}

function renderHistoryTable(){
  if (!els.historyTbody) return;
  els.historyTbody.innerHTML = '';
  ALL_MEASUREMENTS.forEach((m, i) => {
    const tr = document.createElement('tr'); tr.className='trow';
    tr.dataset.id = m.id;
    const date = new Date(m.measuredAt);
    const statusClass = m.nokCount > 0 ? 'nok' : 'ok';

    tr.innerHTML = `
      <td>${i + 1}</td>
      <td><strong>${m.busbarQR}</strong><br><span class="small">${m.typeName} v${m.typeVersion}</span></td>
      <td>${m.operator}<br><span class="small">${m.station}</span></td>
      <td>${date.toLocaleString(CURRENT_LANG)}</td>
      <td><span class="${statusClass}">${m.nokCount} NOK</span></td>
      <td>
        <button class="btn ghost btn-edit-m" data-id="${m.id}" title="${LANGUAGES[CURRENT_LANG].btn_edit_type}">✎</button>
        <button class="btn ghost btn-delete-m" data-id="${m.id}" title="${LANGUAGES[CURRENT_LANG].btn_delete_type}">🗑️</button>
      </td>
    `;
    tr.addEventListener('click', (e) => {
      if (!e.target.matches('button')) loadMeasurement(m);
    });
    els.historyTbody.appendChild(tr);
  });
}

async function deleteMeasurement(id){
  if (!confirm(LANGUAGES[CURRENT_LANG].msg_confirm_delete_measurement)) return;
  await idbDelete(DB_STORE_MEAS, id);
  ALL_MEASUREMENTS = ALL_MEASUREMENTS.filter(m => m.id !== id);
  if (els.historyCount) els.historyCount.textContent = ALL_MEASUREMENTS.length;
  renderHistoryTable();
  historyInfo(LANGUAGES[CURRENT_LANG].msg_deleted_measurement);
  if (MEASUREMENT_ID === id) newMeasurement();
}

async function applyDateFilter(){
    if (!els.chartsModal) return;
    const fromStr = els.filterDateFrom ? els.filterDateFrom.value : '';
    const toStr = els.filterDateTo ? els.filterDateTo.value : '';
    const typeFilter = els.filterBusbarType ? els.filterBusbarType.value : '';
    
    const dateFrom = fromStr ? new Date(fromStr) : null;
    const dateTo = toStr ? new Date(toStr) : null;

    if (dateFrom && dateTo && dateFrom > dateTo) {
        historyError(LANGUAGES[CURRENT_LANG].error_date_range);
        return;
    }

    if (dateFrom || dateTo || typeFilter) {
        FILTERED_MEASUREMENTS = ALL_MEASUREMENTS.filter(m => {
            const mDate = new Date(m.measuredAt);
            const matchesFrom = dateFrom ? mDate >= dateFrom : true;
            const matchesTo = dateTo ? mDate <= dateTo : true;
            const matchesType = typeFilter ? m.typeName === typeFilter : true;
            return matchesFrom && matchesTo && matchesType;
        });
        historyInfo(`${LANGUAGES[CURRENT_LANG].btn_apply_filter} applied: ${FILTERED_MEASUREMENTS.length} records found.`);
    } else {
        FILTERED_MEASUREMENTS = [...ALL_MEASUREMENTS];
        historyInfo(`${LANGUAGES[CURRENT_LANG].btn_apply_filter} removed. Showing all ${FILTERED_MEASUREMENTS.length} records.`);
    }
    
    renderLoadMeasurementToChartSelect();
    if (els.trendPointSelect) updateTrendChart(els.trendPointSelect.value);
}

function clearDateFilter(){
    if (els.filterDateFrom) els.filterDateFrom.value = '';
    if (els.filterDateTo) els.filterDateTo.value = '';
    if (els.filterBusbarType) els.filterBusbarType.value = '';
    applyDateFilter();
}


function renderLoadMeasurementToChartSelect(){
    if (!els.loadMeasurementToChart) return;
    // FIX: Upewnienie się, że placeholder jest poprawnie tłumaczony
    els.loadMeasurementToChart.innerHTML=`<option value="">— ${LANGUAGES[CURRENT_LANG].opt_load_history.replace(/—/g, '')} —</option>`;
    
    FILTERED_MEASUREMENTS.sort((a,b) => new Date(b.measuredAt) - new Date(a.measuredAt)).forEach(m => {
        const date = new Date(m.measuredAt).toLocaleString(CURRENT_LANG);
        const o = document.createElement('option');
        o.value = m.id;
        o.textContent = `${m.busbarQR} (${m.typeName} v${m.typeVersion}, ${date})`;
        els.loadMeasurementToChart.appendChild(o);
    });
}

function updateSingleBusbarChart(m){
  const type = TYPES.find(t => t.id === m.typeId);
  if (!type) { return; } 
  
  // FIX: Only show busbar QR if available
  if (els.currentBusbarQr) {
      if (m.busbarQR) {
          els.currentBusbarQr.textContent = m.busbarQR;
      } else {
          els.currentBusbarQr.textContent = '';
      }
  }

  const dataKeys = type.points.map(p => p.dataKey);
  const aPoints = dataKeys.filter(key => !key.includes('.'));
  const bPoints = dataKeys.filter(key => key.includes('.'));

  const renderSingleChart = (canvasId, keys, title) => {
      const labels = [];
      const rawValues = [];
      const annotations = [];
      let globalMinY = Infinity;
      let globalMaxY = -Infinity;

      const canvas = q(`#${canvasId}`);
      if (!canvas) return;

      keys.forEach(key => {
          const val = m.vals[key];
          const point = type.points.find(p => p.dataKey === key);
          labels.push(point.label);
          rawValues.push(val !== undefined ? val : null);

          if (isFinite(val)) {
              globalMinY = Math.min(globalMinY, val);
              globalMaxY = Math.max(globalMaxY, val);
          }
          if (isFinite(point.tolMin) && point.tolMin < globalMinY) globalMinY = point.tolMin;
          if (isFinite(point.tolMax) && point.tolMax > globalMaxY) globalMaxY = point.tolMax;

          if (isFinite(point.tolMin)) {
              annotations.push({
                  type: 'line', mode: 'horizontal', scaleID: 'y', value: point.tolMin, borderColor: 'var(--nok)', borderWidth: 1, borderDash: [5, 5], 
                  label: { content: 'TOL MIN', enabled: true, position: 'start', color: 'var(--nok)' }
              });
          }
          if (isFinite(point.tolMax)) {
              annotations.push({
                  type: 'line', mode: 'horizontal', scaleID: 'y', value: point.tolMax, borderColor: 'var(--nok)', borderWidth: 1, borderDash: [5, 5],
                  label: { content: 'TOL MAX', enabled: true, position: 'end', color: 'var(--nok)' }
              });
          }
      });
      
      const yMin = Math.floor(globalMinY / 0.1) * 0.1 - 0.2;
      const yMax = Math.ceil(globalMaxY / 0.1) * 0.1 + 0.2;
      
      const existingChart = Chart.getChart(canvas);
      if (existingChart) existingChart.destroy();
      
      new Chart(canvas.getContext('2d'), {
          type: 'line', 
          data: {
              labels: labels,
              datasets: [{
                  label: title,
                  data: rawValues,
                  borderColor: 'var(--accent)',
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  tension: 0.2,
                  fill: false, 
              }]
          },
          options: {
              responsive: true, maintainAspectRatio: false,
              scales: {
                  y: {
                      title: { display: true, text: LANGUAGES[CURRENT_LANG].chart_y_axis }, 
                      beginAtZero: false, 
                      min: yMin, 
                      max: yMax, 
                      grid: { color: 'rgba(255,255,255,0.1)' },
                      ticks: { color: 'var(--text)' }
                  },
                  x: {
                      title: { display: true, text: LANGUAGES[CURRENT_LANG].th_point },
                      grid: { display: false },
                      ticks: { color: 'var(--text)' }
                  }
              },
              plugins: {
                  legend: { display: false },
                  tooltip: { callbacks: { label: (ctx) => `${LANGUAGES[CURRENT_LANG].chart_y_axis}: ${ctx.parsed.y.toFixed(3)} mm` } },
                  annotation: { annotations: annotations.filter(a => a.type) } 
              }
          }
      });
  };

  renderSingleChart('singleBusbarChartA', aPoints, LANGUAGES[CURRENT_LANG].chart_plane_a);
  renderSingleChart('singleBusbarChartB', bPoints, LANGUAGES[CURRENT_LANG].chart_plane_b);
}


function updateTrendPointSelect(){
  const allPoints = [];
  TYPES.forEach(t => t.points.forEach(p => {
      if (!allPoints.includes(p.dataKey)) allPoints.push(p.dataKey);
  }));
  
  allPoints.sort((a,b) => {
    const partsA = a.split('.').map(Number);
    const partsB = b.split('.').map(Number);
    if (partsA[0] !== partsB[0]) return partsA[0] - partsB[0];
    return (partsA[1] || 0) - (partsB[1] || 0);
  });
  
  if (els.trendPointSelect) els.trendPointSelect.innerHTML = allPoints.map(p => `<option value="${p}">Point ${p}</option>`).join('');
  if(allPoints.length) {
    const initialPoint = allPoints[0];
    updateTrendChart(initialPoint); 
  }
}

function updateTrendChart(pointKey){
  if (!FILTERED_MEASUREMENTS.length) { 
    if (trendBusbarChart) {
        const existingChart = Chart.getChart(els.trendChart);
        if (existingChart) existingChart.destroy();
        trendBusbarChart = null;
    }
    return;
  }
  
  // FIX: Ujednolicenie wykresu trendu
  const ctx = els.trendChart ? els.trendChart.getContext('2d') : null;
  if (!ctx) return;

  const labels = [];
  const data = [];
  const borderColors = [];
  let globalMinTol = Infinity;
  let globalMaxTol = -Infinity;

  FILTERED_MEASUREMENTS.sort((a,b) => new Date(a.measuredAt) - new Date(b.measuredAt)).forEach((m) => {
      const type = TYPES.find(t => t.id === m.typeId);
      if (!type) return;

      const point = type.points.find(p => p.dataKey === pointKey);
      const val = m.vals[pointKey];
      const mDateStr = new Date(m.measuredAt).toLocaleString(CURRENT_LANG, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
      labels.push(`${m.busbarQR} (${mDateStr})`);

      if (val !== undefined && point && isFinite(point.tolMin) && isFinite(point.tolMax)) {
          data.push(val);
          const isOk = (val >= point.tolMin && val <= point.tolMax);
          borderColors.push(isOk ? 'var(--ok)' : 'var(--nok)');
          
          globalMinTol = Math.min(globalMinTol, point.tolMin);
          globalMaxTol = Math.max(globalMaxTol, point.tolMax);
      } else {
          data.push(null); 
          borderColors.push('var(--muted)');
      }
  });
  
  const annos = [];
  if (isFinite(globalMinTol) && globalMinTol !== Infinity) {
      annos.push({
          type: 'line', mode: 'horizontal', scaleID: 'y', value: globalMinTol, borderColor: 'var(--nok)', borderWidth: 1, borderDash: [5, 5], 
          label: { content: LANGUAGES[CURRENT_LANG].chart_global_min, enabled: true, position: 'start', color: 'var(--nok)' }
      });
  }
  if (isFinite(globalMaxTol) && globalMaxTol !== -Infinity) {
      annos.push({
          type: 'line', mode: 'horizontal', scaleID: 'y', value: globalMaxTol, borderColor: 'var(--nok)', borderWidth: 1, borderDash: [5, 5],
          label: { content: LANGUAGES[CURRENT_LANG].chart_global_max, enabled: true, position: 'end', color: 'var(--nok)' }
      });
  }
  
  const existingChart = Chart.getChart(els.trendChart);
  if (existingChart) existingChart.destroy();

  trendBusbarChart = new Chart(ctx, {
      type: 'line',
      data: {
          labels: labels || [], 
          datasets: [{
              label: `${LANGUAGES[CURRENT_LANG].th_point} ${pointKey}`,
              data: data,
              borderColor: 'var(--accent)', 
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              tension: 0.1,
              pointBackgroundColor: borderColors,
              pointBorderColor: borderColors,
              fill: false,
          }],
      },
      options: {
          responsive: true, maintainAspectRatio: false,
          scales: {
              y: {
                  title: { display: true, text: LANGUAGES[CURRENT_LANG].chart_y_axis },
                  beginAtZero: false,
                  grid: { color: 'rgba(255,255,255,0.1)' },
                  ticks: { color: 'var(--text)' }
              },
              x: {
                  title: { display: true, text: LANGUAGES[CURRENT_LANG].chart_x_axis },
                  grid: { display: false },
                  ticks: { color: 'var(--text)', autoSkip: true, maxTicksLimit: 10 } 
              }
          },
          plugins: {
              legend: { display: false }, 
              annotation: { annotations: annos }
          }
      }
  });
}


/* ---- Events ---- */
function attachEvents(){
  // FIX: Language buttons are handled in init, just add class updates here
  document.querySelectorAll('.flag-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
          const langKey = e.currentTarget.dataset.langKey;
          updateLanguage(langKey);
          document.querySelectorAll('.flag-btn').forEach(b => b.classList.remove('active'));
          e.currentTarget.classList.add('active');
      });
  });
  
  if (els.tbody) els.tbody.addEventListener('input', (e)=>{
    if (e.target.matches('input')){
      normalizeNumInput(e.target); validateAll();
      CURRENT_MEASUREMENT_DATA = getCurrentMeasurementData(getCurrentType()); 
    }
  });
  if (els.tbody) els.tbody.addEventListener('focusin', (e)=>{ if (e.target.matches('input')) highlightFromFocus(e.target); });
  if (els.busbarQR) els.busbarQR.addEventListener('input', ()=>{
      CURRENT_MEASUREMENT_DATA = getCurrentMeasurementData(getCurrentType());
      if (els.currentBusbarQr) els.currentBusbarQr.textContent = els.busbarQR.value.trim(); 
  });

  if (els.typeSelect) els.typeSelect.addEventListener('change', async (e)=>{
    CURRENT_TYPE_ID = e.target.value; await idbSet(DB_STORE_KV, CURRENT_TYPE_ID, 'currentTypeId');
    buildUIForType(getCurrentType());
  });

  // ************ LOGIKA PRZYCISKÓW TYPU ************
  if (els.addTypeBtn) els.addTypeBtn.addEventListener('click', ()=>openTypeModal(false));
  
  if (els.editTypeBtn) els.editTypeBtn.addEventListener('click', ()=>{
      const type = getCurrentType();
      if (type) {
          openTypeModal(true);
      } else {
          error(LANGUAGES[CURRENT_LANG].msg_select_type);
      }
  });
  // ************************************************************

  // Główne akcje
  if (els.saveMeasurementBtn) els.saveMeasurementBtn.addEventListener('click', saveMeasurement);
  if (els.newMeasurementBtn) els.newMeasurementBtn.addEventListener('click', newMeasurement);
  if (els.showHistoryBtn) els.showHistoryBtn.addEventListener('click', openHistoryModal);
  if (els.showChartsBtn) els.showChartsBtn.addEventListener('click', openChartsModal);
  if (els.importCsvBtn) els.importCsvBtn.addEventListener('click', openImportModal);
  
  // Charts Filter
  if (els.applyDateFilter) els.applyDateFilter.addEventListener('click', applyDateFilter);
  if (els.clearDateFilter) els.clearDateFilter.addEventListener('click', clearDateFilter); 
  if (els.filterBusbarType) els.filterBusbarType.addEventListener('change', applyDateFilter); 

  // Import
  if (els.closeImportModal) els.closeImportModal.addEventListener('click', closeImportModal);
  if (els.startImportBtn) els.startImportBtn.addEventListener('click', startImport);

  // Historia
  if (els.closeHistoryModal) els.closeHistoryModal.addEventListener('click', closeHistoryModal);
  if (els.chooseFolder) els.chooseFolder.addEventListener('click', chooseFolder);
  if (els.exportCsv) els.exportCsv.addEventListener('click', exportCsv);
  
  if (els.historyTbody) els.historyTbody.addEventListener('click', async (e) => {
    const btn = e.target.closest('button');
    if (!btn) return;
    const id = btn.dataset.id;

    if (btn.matches('.btn-edit-m')) {
        const m = ALL_MEASUREMENTS.find(a => a.id === id);
        if (m) loadMeasurement(m);
    }
    if (btn.matches('.btn-delete-m')) deleteMeasurement(id);
  });
  
  // Wykresy
  if (els.closeChartsModal) els.closeChartsModal.addEventListener('click', closeChartsModal);
  if (els.trendPointSelect) els.trendPointSelect.addEventListener('change', (e) => {
    updateTrendChart(e.target.value);
  });
  if (els.loadMeasurementToChart) els.loadMeasurementToChart.addEventListener('change', (e) => {
    const id = e.target.value;
    if (id) {
        const m = FILTERED_MEASUREMENTS.find(a => a.id === id);
        if (m) updateSingleBusbarChart(m);
    } else {
        updateSingleBusbarChart(getCurrentMeasurementData(getCurrentType()));
    }
  });
  
  // Modal typu
  if (els.m_points) els.m_points.addEventListener('change', ()=>{
    const t = readTypeFromModal();
    if (t && els.m_ptTable) els.m_ptTable.dataset.type = JSON.stringify(t);
    renderPtTable(t);
  });
  if (els.copyDown) els.copyDown.addEventListener('click', ()=>{
    const m = els.m_tolMin ? els.m_tolMin.value.trim() : ''; 
    const M = els.m_tolMax ? els.m_tolMax.value.trim() : '';
    if (els.m_ptTable) {
        const inputs = els.m_ptTable.querySelectorAll('input[data-k]');
        inputs.forEach(inp => {
            if(inp.dataset.k === 'tolMin') inp.value = m;
            if(inp.dataset.k === 'tolMax') inp.value = M;
        });
    }
  });
  if (els.resetToDefault) els.resetToDefault.addEventListener('click', ()=>{
    const m = els.m_tolMin ? els.m_tolMin.value.trim() : ''; 
    const M = els.m_tolMax ? els.m_tolMax.value.trim() : '';
    if (els.m_ptTable) {
        const inputs = els.m_ptTable.querySelectorAll('input[data-k]');
        inputs.forEach(inp => {
            inp.value = '';
            if(inp.dataset.k === 'tolMin') inp.placeholder = m || '';
            if(inp.dataset.k === 'tolMax') inp.placeholder = M || '';
        });
    }
  });

  if (els.saveTypeBtn) els.saveTypeBtn.addEventListener('click', async ()=>{
    const before = JSON.stringify(getCurrentType()||{});
    let t = readTypeFromModal();
    if (!t) { error('Error loading type data.'); return; }
    
    const edit = TYPES.some(x=>x.id===EDITING_TYPE_ID);
    if (edit){
      const idx = TYPES.findIndex(x=>x.id===EDITING_TYPE_ID);
      const prev = TYPES[idx];
      const temp = {...t, id: prev.id, name: t.name, evenCount: t.evenCount};
      const changed = JSON.stringify({points:t.points, evenCount:t.evenCount, name:t.name}) !== JSON.stringify({points:prev.points, evenCount:prev.evenCount, name:prev.name});
      temp.version = changed ? (prev.version+1) : prev.version;
      TYPES[idx] = temp;
      CURRENT_TYPE_ID = temp.id;
    } else {
      t.id = EDITING_TYPE_ID;
      TYPES.push(t);
      CURRENT_TYPE_ID = t.id;
    }
    await idbSet(DB_STORE_KV, TYPES, 'types'); await idbSet(DB_STORE_KV, CURRENT_TYPE_ID, 'currentTypeId');
    renderTypeSelect(); buildUIForType(getCurrentType());
    closeModal();
    const after = JSON.stringify(getCurrentType()||{});
    if (before!==after) info(LANGUAGES[CURRENT_LANG].tip_version_increment);
  });

  if (els.deleteTypeBtn) els.deleteTypeBtn.addEventListener('click', async ()=>{
    const t = getCurrentType(); if (!t) return;
    if (!confirm(LANGUAGES[CURRENT_LANG].msg_confirm_delete_type.replace('%s', t.name))) return;
    TYPES = TYPES.filter(x=>x.id!==t.id);
    await idbSet(DB_STORE_KV, TYPES, 'types');
    CURRENT_TYPE_ID = TYPES[0]?.id || null;
    await idbSet(DB_STORE_KV, CURRENT_TYPE_ID, 'currentTypeId');
    renderTypeSelect(); buildUIForType(getCurrentType());
    closeModal(); info(LANGUAGES[CURRENT_LANG].btn_delete_type);
  });

  if (els.closeTypeModal) els.closeTypeModal.addEventListener('click', closeModal);

  if (els.toggleNok) els.toggleNok.addEventListener('click', ()=>{
    const showOnly = els.toggleNok.dataset.only==='1' ? false : true;
    els.toggleNok.dataset.only = showOnly?'1':'0';
    const type = getCurrentType(); if (!type) return;
    for (let i=1;i<=type.evenCount;i++){
      const st = q(`#st-${i}`); const tr = els.tbody.querySelector(`tr[data-pt="${i}"]`);
      const isNok = st && st.classList.contains('status-nok');
      if (tr) tr.style.display = showOnly ? (isNok? 'table-row':'none') : 'table-row';
    }
    if (els.toggleNok) els.toggleNok.textContent = showOnly ? LANGUAGES[CURRENT_LANG].btn_show_nok.replace('only', 'All') : LANGUAGES[CURRENT_LANG].btn_show_nok;
  });

  document.addEventListener('keydown', (e)=>{
    if (e.ctrlKey && e.key==='s'){ e.preventDefault(); saveMeasurement(); }
    if (e.ctrlKey && e.shiftKey && e.key.toLowerCase()==='n'){ e.preventDefault(); newMeasurement(); }
  });

  if (els.tbody) els.tbody.addEventListener('focusin', (e)=> highlightFromFocus(e.target));
  if (els.operator) els.operator.addEventListener('input', ()=> localStorage.setItem('operator', els.operator.value.trim()));
  if (els.station) els.station.addEventListener('input', ()=> localStorage.setItem('station', els.station.value.trim()));
  if (els.busbarQR) els.busbarQR.addEventListener('keydown', (e)=>{ if (e.key==='Enter'){ focusPoint(1); }});
}

/* ---- End Core Logic ---- */

}); 
</script>
</body>
</html>
